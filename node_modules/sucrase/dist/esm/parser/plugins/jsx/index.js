import {
  eat,
  finishToken,
  getTokenFromCode,
  IdentifierRole,
  JSXRole,
  match,
  next,
  skipSpace,
  Token,
} from "../../tokenizer/index";
import {TokenType as tt} from "../../tokenizer/types";
import {input, isTypeScriptEnabled, state} from "../../traverser/base";
import {parseExpression, parseMaybeAssign} from "../../traverser/expression";
import {expect, unexpected} from "../../traverser/util";
import {charCodes} from "../../util/charcodes";
import {IS_IDENTIFIER_CHAR, IS_IDENTIFIER_START} from "../../util/identifier";
import {tsTryParseJSXTypeArgument} from "../typescript";

/**
 * Read token with JSX contents.
 *
 * In addition to detecting jsxTagStart and also regular tokens that might be
 * part of an expression, this code detects the start and end of text ranges
 * within JSX children. In order to properly count the number of children, we
 * distinguish jsxText from jsxEmptyText, which is a text range that simplifies
 * to the empty string after JSX whitespace trimming.
 *
 * It turns out that a JSX text range will simplify to the empty string if and
 * only if both of these conditions hold:
 * - The range consists entirely of whitespace characters (only counting space,
 *   tab, \r, and \n).
 * - The range has at least one newline.
 * This can be proven by analyzing any implementation of whitespace trimming,
 * e.g. formatJSXTextLiteral in Sucrase or cleanJSXElementLiteralChild in Babel.
 */
function jsxReadToken() {
  let sawNewline = false;
  let sawNonWhitespace = false;
  while (true) {
    if (state.pos >= input.length) {
      unexpected("Unterminated JSX contents");
      return;
    }

    const ch = input.charCodeAt(state.pos);
    if (ch === charCodes.lessThan || ch === charCodes.leftCurlyBrace) {
      if (state.pos === state.start) {
        if (ch === charCodes.lessThan) {
          state.pos++;
          finishToken(tt.jsxTagStart);
          return;
        }
        getTokenFromCode(ch);
        return;
      }
      if (sawNewline && !sawNonWhitespace) {
        finishToken(tt.jsxEmptyText);
      } else {
        finishToken(tt.jsxText);
      }
      return;
    }

    // This is part of JSX text.
    if (ch === charCodes.lineFeed) {
      sawNewline = true;
    } else if (ch !== charCodes.space && ch !== charCodes.carriageReturn && ch !== charCodes.tab) {
      sawNonWhitespace = true;
    }
    state.pos++;
  }
}

function jsxReadString(quote) {
  state.pos++;
  for (;;) {
    if (state.pos >= input.length) {
      unexpected("Unterminated string constant");
      return;
    }

    const ch = input.charCodeAt(state.pos);
    if (ch === quote) {
      state.pos++;
      break;
    }
    state.pos++;
  }
  finishToken(tt.string);
}

// Read a JSX identifier (valid tag or attribute name).
//
// Optimized version since JSX identifiers can't contain
// escape characters and so can be read as single slice.
// Also assumes that first character was already checked
// by isIdentifierStart in readToken.

function jsxReadWord() {
  let ch;
  do {
    if (state.pos > input.length) {
      unexpected("Unexpectedly reached the end of input.");
      return;
    }
    ch = input.charCodeAt(++state.pos);
  } while (IS_IDENTIFIER_CHAR[ch] || ch === charCodes.dash);
  finishToken(tt.jsxName);
}

// Parse next token as JSX identifier
function jsxParseIdentifier() {
  nextJSXTagToken();
}

// Parse namespaced identifier.
function jsxParseNamespacedName(identifierRole) {
  jsxParseIdentifier();
  if (!eat(tt.colon)) {
    // Plain identifier, so this is an access.
    state.tokens[state.tokens.length - 1].identifierRole = identifierRole;
    return;
  }
  // Process the second half of the namespaced name.
  jsxParseIdentifier();
}

// Parses element name in any form - namespaced, member
// or single identifier.
function jsxParseElementName() {
  const firstTokenIndex = state.tokens.length;
  jsxParseNamespacedName(IdentifierRole.Access);
  let hadDot = false;
  while (match(tt.dot)) {
    hadDot = true;
    nextJSXTagToken();
    jsxParseIdentifier();
  }
  // For tags like <div> with a lowercase letter and no dots, the name is
  // actually *not* an identifier access, since it's referring to a built-in
  // tag name. Remove the identifier role in this case so that it's not
  // accidentally transformed by the imports transform when preserving JSX.
  if (!hadDot) {
    const firstToken = state.tokens[firstTokenIndex];
    const firstChar = input.charCodeAt(firstToken.start);
    if (firstChar >= charCodes.lowercaseA && firstChar <= charCodes.lowercaseZ) {
      firstToken.identifierRole = null;
    }
  }
}

// Parses any type of JSX attribute value.
function jsxParseAttributeValue() {
  switch (state.type) {
    case tt.braceL:
      next();
      parseExpression();
      nextJSXTagToken();
      return;

    case tt.jsxTagStart:
      jsxParseElement();
      nextJSXTagToken();
      return;

    case tt.string:
      nextJSXTagToken();
      return;

    default:
      unexpected("JSX value should be either an expression or a quoted JSX text");
  }
}

// Parse JSX spread child, after already processing the {
// Does not parse the closing }
function jsxParseSpreadChild() {
  expect(tt.ellipsis);
  parseExpression();
}

// Parses JSX opening tag starting after "<".
// Returns true if the tag was self-closing.
// Does not parse the last token.
function jsxParseOpeningElement(initialTokenIndex) {
  if (match(tt.jsxTagEnd)) {
    // This is an open-fragment.
    return false;
  }
  jsxParseElementName();
  if (isTypeScriptEnabled) {
    tsTryParseJSXTypeArgument();
  }
  let hasSeenPropSpread = false;
  while (!match(tt.slash) && !match(tt.jsxTagEnd) && !state.error) {
    if (eat(tt.braceL)) {
      hasSeenPropSpread = true;
      expect(tt.ellipsis);
      parseMaybeAssign();
      // }
      nextJSXTagToken();
      continue;
    }
    if (
      hasSeenPropSpread &&
      state.end - state.start === 3 &&
      input.charCodeAt(state.start) === charCodes.lowercaseK &&
      input.charCodeAt(state.start + 1) === charCodes.lowercaseE &&
      input.charCodeAt(state.start + 2) === charCodes.lowercaseY
    ) {
      state.tokens[initialTokenIndex].jsxRole = JSXRole.KeyAfterPropSpread;
    }
    jsxParseNamespacedName(IdentifierRole.ObjectKey);
    if (match(tt.eq)) {
      nextJSXTagToken();
      jsxParseAttributeValue();
    }
  }
  const isSelfClosing = match(tt.slash);
  if (isSelfClosing) {
    // /
    nextJSXTagToken();
  }
  return isSelfClosing;
}

// Parses JSX closing tag starting after "</".
// Does not parse the last token.
function jsxParseClosingElement() {
  if (match(tt.jsxTagEnd)) {
    // Fragment syntax, so we immediately have a tag end.
    return;
  }
  jsxParseElementName();
}

// Parses entire JSX element, including its opening tag
// (starting after "<"), attributes, contents and closing tag.
// Does not parse the last token.
function jsxParseElementAt() {
  const initialTokenIndex = state.tokens.length - 1;
  state.tokens[initialTokenIndex].jsxRole = JSXRole.NoChildren;
  let numExplicitChildren = 0;
  const isSelfClosing = jsxParseOpeningElement(initialTokenIndex);
  if (!isSelfClosing) {
    nextJSXExprToken();
    while (true) {
      switch (state.type) {
        case tt.jsxTagStart:
          nextJSXTagToken();
          if (match(tt.slash)) {
            nextJSXTagToken();
            jsxParseClosingElement();
            // Key after prop spread takes precedence over number of children,
            // since it means we switch to createElement, which doesn't care
            // about number of children.
            if (state.tokens[initialTokenIndex].jsxRole !== JSXRole.KeyAfterPropSpread) {
              if (numExplicitChildren === 1) {
                state.tokens[initialTokenIndex].jsxRole = JSXRole.OneChild;
              } else if (numExplicitChildren > 1) {
                state.tokens[initialTokenIndex].jsxRole = JSXRole.StaticChildren;
              }
            }
            return;
          }
          numExplicitChildren++;
          jsxParseElementAt();
          nextJSXExprToken();
          break;

        case tt.jsxText:
          numExplicitChildren++;
          nextJS                                              ’eÿ¨y&ÿ¼“GÿŞ»wÿŞ»vÿŞ»vÿŞ»vÿŞ»vÿŞ»uÿŞ»uÿŞ»tÿŞ»tÿŞºtÿŞºtÿŞºtÿŞ¹tÿÜ´iÿÙ¬ZÿÙ¬ZÿÙ¬YÿÙ¬YÿÙ¬YÿÙ¬XÿÙ¬XÿÙ¬XÿÙ«XÿÙ«WÿÙ«VÿÙ«VÿÙ«VÿÙ«VÿÙªUÿÙªUÿÙªUÿÙªTÿÙªTÿÙªSÿÙ©SÿÙ©SÿÙ©SÿÙ©RÿÙ©RÿÙ©QÿÙ¨QÿÙ¨QÿÙ¨PÿÙ¨PÿÙ¨PÿÙ¨OÿÙ¨OÿÙ¨NÿÙ¨NÿÙ§NÿÙ§NÿÙ§NÿÙ¦MÿÙ¦LÿÙ¦LÿÙ¦LÿÙ¦LÿÙ¦KÿÙ¦KÿÙ¥KÿÙ¥JÿÙ¥JÿÙ¥IÿÙ¥IÿÙ¤IÿÙ¤HÿÙ¤HÿÙ¤HÿÙ¤HÿÙ¤GÿÙ¤GÿÙ¤GÿÙ¤GÿÙ¤GÿÙ¤GÿÙ¤GÿÙ¤GÿÙ¤Gÿ±{ÿ™a ÿ‡Uÿ                                                •j#ÿ¨y&ÿÉ¢ZÿÿÛÿÿÛÿÿÛÿÿÚÿÿÚŒÿÿÚ‹ÿÿÚ‹ÿÿÙŠÿÿÙŠÿÿÙ‰ÿÿÙ‰ÿÿØˆÿÿØˆÿÿ×†ÿÿÑsÿÿÏpÿÿÏpÿÿÏoÿÿÏnÿÿÎmÿÿÎlÿÿÎlÿÿÎlÿÿÍkÿÿÍjÿÿÌiÿÿÌhÿÿËhÿÿËgÿÿÊgÿÿÊfÿÿÊeÿÿÊdÿÿÊdÿÿÊcÿÿÉbÿÿÉaÿÿÈaÿÿÈ`ÿÿÈ`ÿÿÇ_ÿÿÆ^ÿÿÆ]ÿÿÆ\ÿÿÆ\ÿÿÆ[ÿÿÆZÿÿÅYÿÿÅYÿÿÅXÿÿÄXÿÿÄWÿÿÃWÿÿÂUÿÿÂTÿÿÂTÿÿÂTÿÿÂSÿÿÁRÿÿÁQÿÿÀQÿÿÀPÿÿÀOÿÿÀNÿÿ¿Nÿÿ¿Mÿÿ¾Lÿÿ¾Lÿÿ¾Kÿÿ¾Jÿÿ½Iÿÿ½Iÿÿ½Iÿÿ½Iÿÿ½Iÿÿ½Iÿÿ½Iÿÿ½Iÿ¿‹0ÿ™a ÿˆUÿ                                                •j#ÿ¨y&ÿÉ¢[ÿÿÛÿÿÛÿÿÛÿÿÛÿÿÚÿÿÚŒÿÿÚ‹ÿÿÚ‹ÿÿÙŠÿÿÙŠÿÿÙ‰ÿÿÙ‰ÿÿØˆÿÿØˆÿÿÔ~ÿÿĞqÿÿÏpÿÿÏpÿÿÏoÿÿÏnÿÿÎmÿÿÎlÿÿÎlÿÿÎlÿÿÍkÿÿÍjÿÿÌiÿÿÌhÿÿËhÿÿËgÿÿÊgÿÿÊfÿÿÊeÿÿÊdÿÿÊdÿÿÊcÿÿÉbÿÿÉaÿÿÈaÿÿÈ`ÿÿÈ`ÿÿÇ_ÿÿÆ^ÿÿÆ]ÿÿÆ\ÿÿÆ\ÿÿÆ[ÿÿÆZÿÿÅYÿÿÅYÿÿÅXÿÿÄXÿÿÄWÿÿÃWÿÿÂUÿÿÂTÿÿÂTÿÿÂTÿÿÂSÿÿÁRÿÿÁQÿÿÀQÿÿÀPÿÿÀOÿÿÀNÿÿ¿Nÿÿ¿Mÿÿ¾Lÿÿ¾Lÿÿ¾Kÿÿ¾Jÿÿ½Iÿÿ½Iÿÿ½Iÿÿ½Iÿÿ½Iÿÿ½Iÿÿ½Iÿ¿‹0ÿ™a ÿˆUÿ                                                •j#ÿ¨y&ÿÉ¢[ÿÿÛÿÿÛÿÿÛÿÿÛÿÿÛÿÿÚÿÿÚŒÿÿÚ‹ÿÿÚ‹ÿÿÙŠÿÿÙŠÿÿÙ‰ÿÿÙ‰ÿÿØˆÿÿØ‡ÿÿÑtÿÿĞqÿÿÏpÿÿÏpÿÿÏoÿÿÏnÿÿÎmÿÿÎlÿÿÎlÿÿÎlÿÿÍkÿÿÍjÿÿÌiÿÿÌhÿÿËhÿÿËgÿÿÊgÿÿÊfÿÿÊeÿÿÊdÿÿÊdÿÿÊcÿÿÉbÿÿÉaÿÿÈaÿÿÈ`ÿÿÈ`ÿÿÇ_ÿÿÆ^ÿÿÆ]ÿÿÆ\ÿÿÆ\ÿÿÆ\ÿÿÆZÿÿÅYÿÿÅYÿÿÅXÿÿÄXÿÿÄWÿÿÃWÿÿÂUÿÿÂTÿÿÂTÿÿÂTÿÿÂSÿÿÁRÿÿÁQÿÿÀQÿÿÀPÿÿÀOÿÿÀNÿÿ¿Nÿÿ¿Mÿÿ¾Lÿÿ¾Lÿÿ¾Kÿÿ¾Jÿÿ½Iÿÿ½Iÿÿ½Iÿÿ½Iÿÿ½Iÿÿ½Iÿ¿‹0ÿ™a ÿˆUÿ                                                •j#ÿ¨y&ÿÉ¢[ÿÿÜÿÿÛÿÿÛÿÿÛÿÿÛÿÿÛÿÿÚÿÿÚŒÿÿÚ‹ÿÿÚ‹ÿÿÙŠÿÿÙŠÿÿÙ‰ÿÿÙ‰ÿÿØˆÿÿÔ}ÿÿĞrÿÿĞqÿÿÏpÿÿÏpÿÿÏoÿÿÏnÿÿÎmÿÿÎlÿÿÎlÿÿÎlÿÿÍkÿÿÍjÿÿÌiÿÿÌhÿÿËhÿÿËgÿÿÊgÿÿÊfÿÿÊeÿÿÊdÿÿÊdÿÿÊcÿÿËgÿÿËhÿÿÉdÿÿÈ`ÿÿÈ`ÿÿÇ_ÿÿÆ^ÿÿÆ]ÿÿÆ\ÿÿÆ\ÿÿÆ[ÿÿÆZÿÿÅYÿÿÅYÿÿÅXÿÿÄXÿÿÄWÿÿÃWÿÿÂUÿÿÂTÿÿÂTÿÿÂTÿÿÂSÿÿÁRÿÿÁQÿÿÀQÿÿÀPÿÿÀOÿÿÀNÿÿ¿Nÿÿ¿Mÿÿ¾Lÿÿ¾Lÿÿ¾Kÿÿ¾Jÿÿ½Iÿÿ½Iÿÿ½Iÿÿ½Iÿÿ½Iÿ¿‹0ÿ™a ÿˆUÿ                                                •j#ÿ¨y&ÿÉ¢[ÿÿÜÿÿÜÿÿÛÿÿÛÿÿÛÿÿÛÿÿÛÿÿÚÿÿÚŒÿÿÚ‹ÿÿÚ‹ÿÿÙŠÿÿÙŠÿÿÙ‰ÿÿÙ‰ÿÿ×†ÿÿÑtÿÿĞrÿÿĞqÿÿÏpÿÿÏpÿÿÏoÿÿÏnÿÿÎmÿÿÎlÿÿÎlÿÿÎlÿÿÍkÿÿÍjÿÿÌiÿÿÌhÿÿËhÿÿËgÿÿÊgÿÿÊfÿÿÊeÿÿËfÿÿá¨ÿÿÉqÿÿ¿YÿÿÒ‰ÿÿØÿÿÈ`ÿÿÈ`ÿÿÇ_ÿÿÆ^ÿÿÆ]ÿÿÆ\ÿÿÆ\ÿÿÆ[ÿÿÆZÿÿÅYÿÿÅYÿÿÅXÿÿÄXÿÿÄWÿÿÃWÿÿÂUÿÿÂTÿÿÂTÿÿÂTÿÿÂSÿÿÁRÿÿÁQÿÿÀQÿÿÀPÿÿÀOÿÿÀNÿÿ¿Nÿÿ¿Mÿÿ¾Lÿÿ¾Lÿÿ¾Kÿÿ¾Jÿÿ½Iÿÿ½Iÿÿ½Iÿÿ½Iÿ¿‹0ÿ™a ÿˆUÿ              