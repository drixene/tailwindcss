"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    updateAllClasses: function() {
        return updateAllClasses;
    },
    asValue: function() {
        return asValue;
    },
    parseColorFormat: function() {
        return parseColorFormat;
    },
    asColor: function() {
        return asColor;
    },
    asLookupValue: function() {
        return asLookupValue;
    },
    typeMap: function() {
        return typeMap;
    },
    coerceValue: function() {
        return coerceValue;
    },
    getMatchingTypes: function() {
        return getMatchingTypes;
    }
});
const _escapeCommas = /*#__PURE__*/ _interop_require_default(require("./escapeCommas"));
const _withAlphaVariable = require("./withAlphaVariable");
const _dataTypes = require("./dataTypes");
const _negateValue = /*#__PURE__*/ _interop_require_default(require("./negateValue"));
const _validateFormalSyntax = require("./validateFormalSyntax");
const _featureFlags = require("../featureFlags.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function updateAllClasses(selectors, updateClass) {
    selectors.walkClasses((sel)=>{
        sel.value = updateClass(sel.value);
        if (sel.raws && sel.raws.value) {
            sel.raws.value = (0, _escapeCommas.default)(sel.raws.value);
        }
    });
}
function resolveArbitraryValue(modifier, validate) {
    if (!isArbitraryValue(modifier)) {
        return undefined;
    }
    let value = modifier.slice(1, -1);
    if (!validate(value)) {
        return undefined;
    }
    return (0, _dataTypes.normalize)(value);
}
function asNegativeValue(modifier, lookup = {}, validate) {
    let positiveValue = lookup[modifier];
    if (positiveValue !== undefined) {
        return (0, _negateValue.default)(positiveValue);
    }
    if (isArbitraryValue(modifier)) {
        let resolved = resolveArbitraryValue(modifier, validate);
        if (resolved === undefined) {
            return undefined;
        }
        return (0, _negateValue.default)(resolved);
    }
}
function asValue(modifier, options = {}, { validate =()=>true  } = {}) {
    var _options_values;
    let value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];
    if (value !== undefined) {
        return value;
    }
    if (options.supportsNegativeValues && modifier.startsWith("-")) {
        return asNegativeValue(modifier.slice(1), options.values, validate);
    }
    return resolveArbitraryValue(modifier, validate);
}
function isArbitraryValue(input) {
    return input.startsWith("[") && input.endsWith("]");
}
function splitUtilityModifier(modifier) {
    let slashIdx = modifier.lastIndexOf("/");
    // If the `/` is inside an arbitrary, we want to find the previous one if any
    // This logic probably isn't perfect but it should work for most cases
    let arbitraryStartIdx = modifier.lastIndexOf("[", slashIdx);
    let arbitraryEndIdx = modifier.indexOf("]", slashIdx);
    let isNextToArbitrary = modifier[slashIdx - 1] === "]" || modifier[slashIdx + 1] === "[";
    // Backtrack to the previous `/` if the one we found was inside an arbitrary
    if (!isNextToArbitrary) {
        if (arbitraryStartIdx !== -1 && arbitraryEndIdx !== -1) {
            if (arbitraryStartIdx < slashIdx && slashIdx < arbitraryEndIdx) {
                slashIdx = modifier.lastIndexOf("/", arbitraryStartIdx);
            }
        }
    }
    if (slashIdx === -1 || slashIdx === modifier.length - 1) {
        return [
            modifier,
            undefined
        ];
    }
    let arbitrary = isArbitraryValue(modifier);
    // The modifier could be of the form `[foo]/[bar]`
    // We want to handle this case properly
    // without affecting `[foo/bar]`
    if (arbitrary && !modifier.includes("]/[")) {
        return [
            modifier,
            undefined
        ];
    }
    return [
        modifier.slice(0, slashIdx),
        modifier.slice(slashIdx + 1)
    ];
}
function parseColorFormat(value) {
    if (typeof value === "string" && value.includes("<alpha-value>")) {
        let oldValue = value;
        return ({ opacityValue =1  })=>oldValue.replace("<alpha-value>", opacityValue);
    }
    return value;
}
function unwrapArbitraryModifier(modifier) {
    return (0, _dataTypes.normalize)(modifier.slice(1, -1));
}
function asColor(modifier, options = {}, { tailwindConfig ={}  } = {}) {
    var _options_values;
    if (((_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier]) !== undefined) {
        var _options_values1;
        return parseColorFormat((_options_values1 = options.values) === null || _options_values1 === void 0 ? void 0 : _options_values1[modifier]);
    }
    // TODO: Hoist this up to getMatchingTypes or something
    // We do this here because we need the alpha value (if any)
    let [color, alpha] = splitUtilityModifier(modifier);
    if (alpha !== undefined) {
        var _options_values2, _tailwindConfig_theme, _tailwindConfig_theme_opacity;
        var _options_values_color;
        let normalizedColor = (_options_values_color = (_options_values2 = options.values) === null || _options_values2 === void 0 ? void 0 : _options_values2[color]) !== null && _options_values_color !== void 0 ? _options_values_color : isArbitraryValue(color) ? color.slice(1, -1) : undefined;
        if (normalizedColor === undefined) {
            return undefined;
        }
        normalizedColor = parseColorFormat(normalizedColor);
        if (isArbitraryValue(alpha)) {
            return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, unwrapArbitraryModifier(alpha));
        }
        if (((_tailwindConfig_theme = tailwindConfig.theme) === null || _tailwindConfig_theme === void 0 ? void 0 : (_tailwindConfig_theme_opacity = _tailwindConfig_theme.opacity) === null || _tailwindConfig_theme_opacity === void 0 ? void 0 : _tailwindConfig_theme_opacity[alpha]) === undefined) {
            return undefined;
        }
        return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, tailwindConfig.theme.opacity[alpha]);
    }
    return asValue(modifier, options, {
        validate: _dataTypes.color
    });
}
function asLookupValue(modifier, options = {}) {
    var _options_values;
    return (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];
}
function guess(validate) {
    return (modifier, options)=>{
        return asValue(modifier, options, {
            validate
        });
    };
}
let typeMap = {
    any: asValue,
    color: asColor,
    url: guess(_dataTypes.url),
    image: guess(_dataTypes.image),
    length: guess(_dataTypes.length),
    percentage: guess(_dataTypes.percentage),
    position: guess(_dataTypes.position),
    lookup: asLookupValue,
    "generic-name": guess(_dataTypes.genericName),
    "family-name": guess(_dataTypes.familyName),
    number: guess(_dataTypes.number),
    "line-width": guess(_dataTypes.lineWidth),
    "absolute-size": guess(_dataTypes.absoluteSize),
    "relative-size": guess(_dataTypes.relativeSize),
    shadow: guess(_dataTypes.shadow),
    size: guess(_validateFormalSyntax.backgroundSize)
};
let supportedTypes = Object.keys(typeMap);
function splitAtFirst(input, delim) {
    let idx = input.indexOf(delim);
    if (idx === -1) return [
        undefined,
        input
    ];
    return [
        input.slice(0, idx),
        input.slice(idx + 1)
    ];
}
function coerceValue(types, modifier, options, tailwindConfig) {
    if (options.values && modifier in options.values) {
        for (let { type  } of types !== null && types !== void 0 ? types : []){
            let result = typeMap[type](modifier, options, {
                tailwindConfig
            });
            if (result === undefined) {
                continue;
            }
            return [
                result,
  €ü+g„@©¤ï(¾*NtÇ€ôÜ‚       $     @8         yñ²qcè­”^G¡é”Ò~nLì=±ƒUÊä\MÀ       +     @8         5™ñ7M>|]9'H±NK
ÁÀùÆG®ESPfTÃ)       .     @8         æ'Q³môø.U~ÉDŸ%Là¼hkÙÂÇ§9Xå‹g       5     @8         ºıp.húÜ§–‹E.Ø%wo•ÿQJr¼oA8       6     @8         =Wx%?24r€?@ğO¤‚ıpû-«f%şc¸ÍIÆ¤İ       8     @8         Lı%¬«‚—p{C:Ic‰ãó±1¼Ã®Å~Ó]ß¤       €     @8         tmaG*²˜uO¤Ü£Z%ãˆYç¯Àz¹áy«:8¢«`            @8         (GĞ¾`,B¤RDÚ÷¸àì##;jeÜ’	       ›     @8         ?‰Ä©JÀ©~ïY¶`ÙØ±#f–SäÙcOäÕ*›·       9     @8         ñl¦Pºõ¸QQİ*[%†“ÕïAU5x"µÃan•       ;     @8         òÚ ¾Ffœ8V_Ì¬·ÒğÁÆkÙÍ¯ïÃŠıÙ–O:       <     @8         ´1o.8Òê™c½İê§¹¼ı©¶ÜŞ‚–ü¹2~Éíõ       ©     @8         7#¨¼ï1ë—)‚€/Ã11CkHQüÏà"ÇÀ‰–e       >     @8         O °yĞr¢fèÃl-ŠÌq"ƒÊ(gêÎÌT=       ¬     @8         *Kä¬Ç¤÷Õjš‰ğ©nğV'|„ïÛ„ÆÔå       ®     @8         zú-˜â/Ì6y`Fü_£ê&©)Ã|@Ò#Wş¾{'       ?     @8         	9°eH´º€Ó^(÷ØÚÉÙf/ÔB²'èäİ€ò´V       »     @8         lä¶8K‘7ã‰¤©àH²SƒmĞoØ˜v…Å4áËşÎÄ²       ¼     @8         ı~î\ÁUÚ¬İü(×‡D¤öf !Œ8‡®¢„Ÿ5:$       Ä     @8         Üxá2Ü•t3(BØö™àÀ"×ôå/ÔH)O°ÁRó’       É     @8         öP’(VŞGËÉ]p5@ÎñÇz»»hï46±ª       Ë     @8         ¼ìQ¢ÆY'·3oŒR”ùÆæ^Q˜]M\ÎKíKš´       Ò     @8         %õş¨û­œPÓasùìës5Óˆ“ÕsSS›_L½       Ô     @8         s@ã$´ Í\R¾TºrÏ·}æë`÷QrÚe’Š       Õ     @8         $œYr—,ô´Å-î“*ösÛPÿï¸¬ ÆJëè$2ëÍìg       Ö     @8         û'ğløƒ~ğZT%‘=ÖV¥Ä_FMšÍÁô‘       Ø     @8         \ÙŒİºœ¤NŠx®˜à
…_{~Xo¬*ûœÿó2@4(       Ú     @8         •X,~»ŒÕ´Ú‘áì	ÎŒ ©Ç®D1õ‡Î>Û‘3l6       İ     @8         s_sÙvÈU¾µ0£âú”ò„{ákµüºüeäõ       ß     @8         ’Š“;6+B‚/?Ù5Ï“0?sèî¡±jÓí~şÏ$       ã     @8         ôe¢D>ºÉ ­ÚF‹n·ª±s¥\‰ó™ì7	vkéÏ       î     @8         ºŒhÁJ®‹€Ålik_$!ı;“T©×rB       ğ     @8         1
Tè/~¡&ENÕ{â`äß¨Ü».ªÓ!Ô       ÷     @,        ^aT¦â–|x7]À,ßÚ 9s›yD       À     @8         xç0=ÿ›¡pú›‰6‡½'Aİ´|‡‹—X}cdo       ù     @8         Ÿ¾.b6gDÃxå•íŞ…º	îg`T©kÌş'Qxì       È     @8         …xùÎËöK™šÆzı_…c?;?¤iÏ0ù”ÉZ       ı     @8         ßºJpQ†q›7§,v ùï1åìoæ?W¥»       Ô     @8         ›`Ã¶uÇwÙ‘Ëw5‰>²=]I§¡×ê\E[Aá=       Ö     @8         Xo)óª8×Š6öj|¤(r¶–‚EˆM!­M£       Û     @8         ¶0•$pJßOßÂ™¬½—ÒcXâêí˜Õr‰+       @     @8         º)"B¡Lc€İN…bæ¹v¥k­gäõ5jÚƒU       ÿ     @8         cS"ƒ;Ÿ<‰ŸcÅht,. 2Í(jóŒcl       å     @8         @¼O_ùíÛl¹F1 ÁÏÖ`yÀz2ıã/‘6…u)‡       n     @8         ğßOkE(Îó¡Í3!üŠ¼Õ˜ónljA£¢5xÁ       ü     @,        í3AƒM…öÍßÑˆo÷×)¥¥       x     @8   